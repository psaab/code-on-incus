name: CI

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

on:
  pull_request:
    branches: [master, main]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  # Build job gates all tests - nothing runs if build fails
  build:
    name: Build
    runs-on: ubuntu-24.04
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Set up Go
        uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6.2.0
        with:
          go-version: '1.24'
          cache: true

      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@55c2c1448f86e01eaae002a5a3a9624417608d84 # v6.5.2
        with:
          version: latest
          args: --timeout=5m

      - name: Build
        run: go build -v ./...

  # Go unit tests run in parallel with integration tests (after build passes)
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-24.04
    needs: build
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Set up Go
        uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6.2.0
        with:
          go-version: '1.24'
          cache: true

      - name: Run unit tests with coverage and race detector
        run: |
          go test -v -race -coverprofile=coverage.out -covermode=atomic ./...
          go tool cover -func=coverage.out | tail -1  # Show total coverage

  # Integration tests run in parallel with unit tests (after build passes)
  integration:
    name: Integration Tests
    runs-on: ubuntu-24.04
    needs: build
    timeout-minutes: 60
    steps:
      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1

      - name: Set up Go
        uses: actions/setup-go@7a3fe6cf4cb3a834922a1244abfce67bcef6a0c5 # v6.2.0
        with:
          go-version: '1.24'
          cache: true

      - name: Set up Python
        uses: actions/setup-python@83679a892e2d95755f2dac6acb0bfd1e9ac5d548 # v6.1.0
        with:
          python-version: '3.12'

      - name: Cache Python dependencies
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements*.txt', '**/pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r tests/support/requirements.txt

      - name: Lint Python code with ruff
        run: |
          echo "Running ruff linter on Python test code..."
          ruff check tests/
          echo "Checking Python code formatting..."
          ruff format --check tests/

      - name: Install Incus
        run: |
          # Add Zabbly repo for latest Incus
          sudo mkdir -p /etc/apt/keyrings/
          sudo curl -fsSL https://pkgs.zabbly.com/key.asc -o /etc/apt/keyrings/zabbly.asc
          sudo sh -c 'cat <<SOURCES > /etc/apt/sources.list.d/zabbly-incus-stable.sources
          Enabled: yes
          Types: deb
          URIs: https://pkgs.zabbly.com/incus/stable
          Suites: $(. /etc/os-release && echo ${VERSION_CODENAME})
          Components: main
          Architectures: $(dpkg --print-architecture)
          Signed-By: /etc/apt/keyrings/zabbly.asc
          SOURCES'

          sudo apt-get update
          sudo apt-get install -y incus

      - name: Initialize Incus
        run: |
          # Wait for Incus service to be ready
          sudo systemctl start incus.socket || true
          sleep 5

          # Configure subuid/subgid for UID mapping (needed for raw.idmap)
          # Map runner UID 1001 to be available for container remapping
          echo "root:1001:1" | sudo tee -a /etc/subuid
          echo "root:1001:1" | sudo tee -a /etc/subgid

          # Restart Incus to pick up subuid/subgid changes
          sudo systemctl restart incus || true
          sleep 5

          # Initialize Incus with btrfs storage (faster than default dir storage)
          # Using preseed for explicit configuration
          cat <<EOF | sudo incus admin init --preseed
          config:
            images.compression_algorithm: none
          networks:
          - config:
              ipv4.address: auto
              ipv6.address: auto
            name: incusbr0
            type: bridge
          storage_pools:
          - config:
              size: 15GiB
            name: default
            driver: btrfs
          profiles:
          - config: {}
            devices:
              eth0:
                name: eth0
                network: incusbr0
                type: nic
              root:
                path: /
                pool: default
                type: disk
            name: default
          EOF

          # Allow access without re-login by changing socket permissions
          sudo chmod 666 /var/lib/incus/unix.socket

          # Add current user to incus-admin group
          sudo usermod -aG incus-admin $USER

          # Ensure NAT is enabled on the bridge
          incus network set incusbr0 ipv4.nat=true
          incus network set incusbr0 ipv6.nat=true

      - name: Check kernel idmap support
        run: |
          echo "Kernel version:"
          uname -r
          echo "Checking for idmapped mount support:"
          grep -i idmap /proc/filesystems || echo "No idmap in /proc/filesystems"
          echo "Checking btrfs features:"
          sudo btrfs filesystem df /var/lib/incus/storage-pools/default || true
          echo "AppArmor status:"
          sudo aa-status | grep incus || echo "No incus AppArmor profiles"
          echo "Checking if AppArmor is blocking bind mounts:"
          sudo dmesg | grep -i "apparmor.*denied" | tail -20 || echo "No recent AppArmor denials"

      - name: Configure networking for Incus
        run: |
          # Enable IP forwarding (required for container networking)
          echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward > /dev/null
          echo 1 | sudo tee /proc/sys/net/ipv6/conf/all/forwarding > /dev/null

          # Get default interface for outbound traffic
          DEFAULT_IFACE=$(ip route | grep default | awk '{print $5}' | head -1)

          # Use DOCKER-USER chain (same approach as canonical/setup-lxd)
          # Docker respects this chain and won't interfere with our rules
          if sudo iptables -nL DOCKER-USER 2>/dev/null; then
            sudo iptables -I DOCKER-USER -i incusbr0 -j ACCEPT
            sudo iptables -I DOCKER-USER -o incusbr0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
          else
            # Fallback to FORWARD chain if DOCKER-USER doesn't exist
            sudo iptables -P FORWARD ACCEPT
            sudo iptables -I FORWARD 1 -i incusbr0 -j ACCEPT
            sudo iptables -I FORWARD 1 -o incusbr0 -j ACCEPT
          fi

          # Add NAT/MASQUERADE rules for Incus bridge subnet
          BRIDGE_SUBNET=$(ip -4 addr show incusbr0 | grep -oP 'inet \K[\d.]+/\d+' || echo "")
          if [ -n "$BRIDGE_SUBNET" ]; then
            sudo iptables -t nat -I POSTROUTING 1 -s $BRIDGE_SUBNET -o $DEFAULT_IFACE -j MASQUERADE
          fi

          # Add NAT rules for common private IP ranges
          sudo iptables -t nat -I POSTROUTING 1 -s 10.0.0.0/8 ! -d 10.0.0.0/8 -o $DEFAULT_IFACE -j MASQUERADE
          sudo iptables -t nat -I POSTROUTING 1 -s 172.16.0.0/12 ! -d 172.16.0.0/12 -o $DEFAULT_IFACE -j MASQUERADE
          sudo iptables -t nat -I POSTROUTING 1 -s 192.168.0.0/16 ! -d 192.168.0.0/16 -o $DEFAULT_IFACE -j MASQUERADE

      - name: Pre-cache base Ubuntu image
        run: |
          # Pre-download the base image to speed up builds
          echo "Pre-caching Ubuntu 22.04 base image..."
          incus image copy images:ubuntu/22.04 local: --alias ubuntu-22.04 --auto-update=false || true
          incus image list

      - name: Build COI binary
        run: |
          go build -o coi ./cmd/coi
          ./coi version

      - name: Test bind mount functionality
        run: |
          echo "Testing if bind mounts work with shift=true..."

          # Create test directory and file
          mkdir -p /tmp/test-bind-mount
          echo "test-content" > /tmp/test-bind-mount/test-file.txt

          # Launch test container
          incus launch images:ubuntu/22.04 test-bind-mount-container
          sleep 5

          # Add bind mount with shift=true
          incus config device add test-bind-mount-container testmount disk source=/tmp/test-bind-mount path=/mnt/test shift=true

          # Check if file is visible inside container
          echo "Files in container /mnt/test:"
          incus exec test-bind-mount-container -- ls -la /mnt/test/

          # Try to read the file
          echo "Reading file from container:"
          incus exec test-bind-mount-container -- cat /mnt/test/test-file.txt || echo "FAILED: Cannot read file in container"

          # Try to create a file from inside container
          incus exec test-bind-mount-container -- sh -c 'echo "created-from-container" > /mnt/test/created.txt'

          # Check if file appears on host
          if [ -f /tmp/test-bind-mount/created.txt ]; then
            echo "SUCCESS: File created in container is visible on host"
            cat /tmp/test-bind-mount/created.txt
          else
            echo "FAILED: File created in container NOT visible on host"
            ls -la /tmp/test-bind-mount/
          fi

          # Cleanup
          incus delete test-bind-mount-container --force
          rm -rf /tmp/test-bind-mount

      - name: Restore COI image from cache
        id: cache-coi-image
        uses: actions/cache/restore@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: /tmp/coi-image.tar.gz
          key: ${{ runner.os }}-coi-image-${{ hashFiles('internal/image/**', 'testdata/dummy/**', 'scripts/build/**') }}

      - name: Import COI image from cache
        if: steps.cache-coi-image.outputs.cache-hit == 'true'
        run: |
          echo "Restoring COI image from cache..."
          incus image import /tmp/coi-image.tar.gz --alias coi
          ./coi images

      - name: Build COI image
        if: steps.cache-coi-image.outputs.cache-hit != 'true'
        run: |
          echo "Building COI image (not cached)..."
          ./coi build
          ./coi images
          # Export image for caching
          incus image export coi /tmp/coi-image

      - name: Save COI image to cache
        if: steps.cache-coi-image.outputs.cache-hit != 'true'
        uses: actions/cache/save@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: /tmp/coi-image.tar.gz
          key: ${{ runner.os }}-coi-image-${{ hashFiles('internal/image/**', 'testdata/dummy/**', 'scripts/build/**') }}

      - name: Run integration tests with coverage
        run: |
          # Run all integration tests with coverage reporting
          # Tests marked with @pytest.mark.skipif will be automatically skipped in CI
          # --durations=0 shows timing for all tests to help identify slow tests
          # --cov-report=term-missing shows which lines aren't covered
          python -m pytest tests/ -v --tb=short --durations=0 --cov=tests --cov-report=term-missing
        env:
          COI_BINARY: ./coi

      - name: Cleanup
        if: always()
        run: |
          ./coi kill --all --force || true
          ./coi clean --force || true

  ci-success:
    name: CI Success
    runs-on: ubuntu-24.04
    timeout-minutes: 5
    if: always()
    needs:
      - build
      - unit-tests
      - integration
    steps:
      - name: Check all jobs passed
        if: |
          contains(needs.*.result, 'failure') ||
          contains(needs.*.result, 'cancelled') ||
          contains(needs.*.result, 'skipped')
        run: exit 1
      - run: echo "All CI checks passed!"
